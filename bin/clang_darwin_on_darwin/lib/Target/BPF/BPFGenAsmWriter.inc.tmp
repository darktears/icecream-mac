/*===- TableGen'erated file -------------------------------------*- C++ -*-===*\
|*                                                                            *|
|* Assembly Writer Source Fragment                                            *|
|*                                                                            *|
|* Automatically generated file, do not edit!                                 *|
|*                                                                            *|
\*===----------------------------------------------------------------------===*/

/// printInstruction - This method is automatically generated by tablegen
/// from the instruction set description.
void BPFInstPrinter::printInstruction(const MCInst *MI, raw_ostream &O) {
  static const char AsmStrs[] = {
  /* 0 */ 'b', 's', 'w', 'a', 'p', '3', '2', 9, 0,
  /* 9 */ 'b', 's', 'w', 'a', 'p', '6', '4', 9, 0,
  /* 18 */ 'b', 's', 'w', 'a', 'p', '1', '6', 9, 0,
  /* 27 */ 'l', 'e', 'a', 9, 0,
  /* 32 */ 'l', 'd', '_', 'p', 's', 'e', 'u', 'd', 'o', 9, 0,
  /* 43 */ 'n', 'o', 'p', 9, 0,
  /* 48 */ '#', 'A', 'D', 'J', 'C', 'A', 'L', 'L', 'S', 'T', 'A', 'C', 'K', 'D', 'O', 'W', 'N', 32, 0,
  /* 67 */ '#', 32, 'S', 'e', 'l', 'e', 'c', 't', 32, 'P', 'S', 'E', 'U', 'D', 'O', 32, 0,
  /* 84 */ '#', 'A', 'D', 'J', 'C', 'A', 'L', 'L', 'S', 'T', 'A', 'C', 'K', 'U', 'P', 32, 0,
  /* 101 */ 'i', 'f', 32, 0,
  /* 105 */ 'c', 'a', 'l', 'l', 32, 0,
  /* 111 */ 'g', 'o', 't', 'o', 32, 0,
  /* 117 */ 'l', 'o', 'c', 'k', 32, '*', '(', 'u', '3', '2', 32, '*', ')', '(', 0,
  /* 132 */ 'l', 'o', 'c', 'k', 32, '*', '(', 'u', '6', '4', 32, '*', ')', '(', 0,
  /* 147 */ '*', '(', 'u', '1', '6', 32, '*', ')', '(', 0,
  /* 157 */ '*', '(', 'u', '8', 32, '*', ')', '(', 0,
  /* 166 */ '#', 32, 'X', 'R', 'a', 'y', 32, 'F', 'u', 'n', 'c', 't', 'i', 'o', 'n', 32, 'P', 'a', 't', 'c', 'h', 'a', 'b', 'l', 'e', 32, 'R', 'E', 'T', '.', 0,
  /* 197 */ '#', 32, 'X', 'R', 'a', 'y', 32, 'F', 'u', 'n', 'c', 't', 'i', 'o', 'n', 32, 'E', 'n', 't', 'e', 'r', '.', 0,
  /* 220 */ '#', 32, 'X', 'R', 'a', 'y', 32, 'T', 'a', 'i', 'l', 32, 'C', 'a', 'l', 'l', 32, 'E', 'x', 'i', 't', '.', 0,
  /* 243 */ '#', 32, 'X', 'R', 'a', 'y', 32, 'F', 'u', 'n', 'c', 't', 'i', 'o', 'n', 32, 'E', 'x', 'i', 't', '.', 0,
  /* 265 */ 'L', 'I', 'F', 'E', 'T', 'I', 'M', 'E', '_', 'E', 'N', 'D', 0,
  /* 278 */ 'B', 'U', 'N', 'D', 'L', 'E', 0,
  /* 285 */ 'D', 'B', 'G', '_', 'V', 'A', 'L', 'U', 'E', 0,
  /* 295 */ 'L', 'I', 'F', 'E', 'T', 'I', 'M', 'E', '_', 'S', 'T', 'A', 'R', 'T', 0,
  /* 310 */ 'r', '0', 32, '=', 32, '*', '(', 'u', '3', '2', 32, '*', ')', 's', 'k', 'b', '[', 0,
  /* 328 */ 'r', '0', 32, '=', 32, '*', '(', 'u', '1', '6', 32, '*', ')', 's', 'k', 'b', '[', 0,
  /* 346 */ 'r', '0', 32, '=', 32, '*', '(', 'u', '8', 32, '*', ')', 's', 'k', 'b', '[', 0,
  /* 363 */ 'e', 'x', 'i', 't', 0,
  };

  static const uint16_t OpInfo0[] = {
    0U,	// PHI
    0U,	// INLINEASM
    0U,	// CFI_INSTRUCTION
    0U,	// EH_LABEL
    0U,	// GC_LABEL
    0U,	// KILL
    0U,	// EXTRACT_SUBREG
    0U,	// INSERT_SUBREG
    0U,	// IMPLICIT_DEF
    0U,	// SUBREG_TO_REG
    0U,	// COPY_TO_REGCLASS
    286U,	// DBG_VALUE
    0U,	// REG_SEQUENCE
    0U,	// COPY
    279U,	// BUNDLE
    296U,	// LIFETIME_START
    266U,	// LIFETIME_END
    0U,	// STACKMAP
    0U,	// PATCHPOINT
    0U,	// LOAD_STACK_GUARD
    0U,	// STATEPOINT
    0U,	// LOCAL_ESCAPE
    0U,	// FAULTING_LOAD_OP
    0U,	// PATCHABLE_OP
    198U,	// PATCHABLE_FUNCTION_ENTER
    167U,	// PATCHABLE_RET
    244U,	// PATCHABLE_FUNCTION_EXIT
    221U,	// PATCHABLE_TAIL_CALL
    0U,	// G_ADD
    0U,	// G_SUB
    0U,	// G_MUL
    0U,	// G_SDIV
    0U,	// G_UDIV
    0U,	// G_SREM
    0U,	// G_UREM
    0U,	// G_AND
    0U,	// G_OR
    0U,	// G_XOR
    0U,	// G_FRAME_INDEX
    0U,	// G_GLOBAL_VALUE
    0U,	// G_EXTRACT
    0U,	// G_INSERT
    0U,	// G_SEQUENCE
    0U,	// G_PTRTOINT
    0U,	// G_INTTOPTR
    0U,	// G_BITCAST
    0U,	// G_LOAD
    0U,	// G_STORE
    0U,	// G_BRCOND
    0U,	// G_INTRINSIC
    0U,	// G_INTRINSIC_W_SIDE_EFFECTS
    0U,	// G_ANYEXT
    0U,	// G_TRUNC
    0U,	// G_CONSTANT
    0U,	// G_FCONSTANT
    0U,	// G_SEXT
    0U,	// G_ZEXT
    0U,	// G_SHL
    0U,	// G_LSHR
    0U,	// G_ASHR
    0U,	// G_ICMP
    0U,	// G_FCMP
    0U,	// G_SELECT
    0U,	// G_UADDE
    0U,	// G_USUBE
    0U,	// G_SADDO
    0U,	// G_SSUBO
    0U,	// G_UMULO
    0U,	// G_SMULO
    0U,	// G_FADD
    0U,	// G_FSUB
    0U,	// G_FMUL
    0U,	// G_FDIV
    0U,	// G_FREM
    0U,	// G_FPEXT
    0U,	// G_FPTRUNC
    0U,	// G_FPTOSI
    0U,	// G_FPTOUI
    0U,	// G_SITOFP
    0U,	// G_UITOFP
    0U,	// G_GEP
    0U,	// G_BR
    521U,	// ADD_ri
    521U,	// ADD_rr
    2609U,	// ADJCALLSTACKDOWN
    4693U,	// ADJCALLSTACKUP
    6665U,	// AND_ri
    6665U,	// AND_rr
    2579U,	// BSWAP16
    2561U,	// BSWAP32
    2570U,	// BSWAP64
    8713U,	// DIV_ri
    8713U,	// DIV_rr
    10780U,	// FI_ri
    2666U,	// JAL
    12902U,	// JEQ_ri
    12902U,	// JEQ_rr
    2672U,	// JMP
    14950U,	// JNE_ri
    14950U,	// JNE_rr
    16998U,	// JSGE_ri
    16998U,	// JSGE_rr
    19046U,	// JSGT_ri
    19046U,	// JSGT_rr
    21094U,	// JUGE_ri
    21094U,	// JUGE_rr
    23142U,	// JUGT_ri
    23142U,	// JUGT_rr
    25097U,	// LDB
    27145U,	// LDD
    29193U,	// LDH
    31241U,	// LDW
    1371U,	// LD_ABS_B
    1353U,	// LD_ABS_H
    1335U,	// LD_ABS_W
    1371U,	// LD_IND_B
    1353U,	// LD_IND_H
    1335U,	// LD_IND_W
    33289U,	// LD_imm64
    10785U,	// LD_pseudo
    33289U,	// MOV_ri
    33289U,	// MOV_rr
    35337U,	// MUL_ri
    35337U,	// MUL_rr
    2604U,	// NOP
    37385U,	// OR_ri
    37385U,	// OR_rr
    364U,	// RET
    39433U,	// SLL_ri
    39433U,	// SLL_rr
    41481U,	// SRA_ri
    41481U,	// SRA_rr
    43529U,	// SRL_ri
    43529U,	// SRL_rr
    46750U,	// STB
    46730U,	// STD
    46740U,	// STH
    46715U,	// STW
    47625U,	// SUB_ri
    47625U,	// SUB_rr
    33348U,	// Select
    50806U,	// XADD32
    50821U,	// XADD64
    51721U,	// XOR_ri
    51721U,	// XOR_rr
  };

  static const uint8_t OpInfo1[] = {
    0U,	// PHI
    0U,	// INLINEASM
    0U,	// CFI_INSTRUCTION
    0U,	// EH_LABEL
    0U,	// GC_LABEL
    0U,	// KILL
    0U,	// EXTRACT_SUBREG
    0U,	// INSERT_SUBREG
    0U,	// IMPLICIT_DEF
    0U,	// SUBREG_TO_REG
    0U,	// COPY_TO_REGCLASS
    0U,	// DBG_VALUE
    0U,	// REG_SEQUENCE
    0U,	// COPY
    0U,	// BUNDLE
    0U,	// LIFETIME_START
    0U,	// LIFETIME_END
    0U,	// STACKMAP
    0U,	// PATCHPOINT
    0U,	// LOAD_STACK_GUARD
    0U,	// STATEPOINT
    0U,	// LOCAL_ESCAPE
    0U,	// FAULTING_LOAD_OP
    0U,	// PATCHABLE_OP
    0U,	// PATCHABLE_FUNCTION_ENTER
    0U,	// PATCHABLE_RET
    0U,	// PATCHABLE_FUNCTION_EXIT
    0U,	// PATCHABLE_TAIL_CALL
    0U,	// G_ADD
    0U,	// G_SUB
    0U,	// G_MUL
    0U,	// G_SDIV
    0U,	// G_UDIV
    0U,	// G_SREM
    0U,	// G_UREM
    0U,	// G_AND
    0U,	// G_OR
    0U,	// G_XOR
    0U,	// G_FRAME_INDEX
    0U,	// G_GLOBAL_VALUE
    0U,	// G_EXTRACT
    0U,	// G_INSERT
    0U,	// G_SEQUENCE
    0U,	// G_PTRTOINT
    0U,	// G_INTTOPTR
    0U,	// G_BITCAST
    0U,	// G_LOAD
    0U,	// G_STORE
    0U,	// G_BRCOND
    0U,	// G_INTRINSIC
    0U,	// G_INTRINSIC_W_SIDE_EFFECTS
    0U,	// G_ANYEXT
    0U,	// G_TRUNC
    0U,	// G_CONSTANT
    0U,	// G_FCONSTANT
    0U,	// G_SEXT
    0U,	// G_ZEXT
    0U,	// G_SHL
    0U,	// G_LSHR
    0U,	// G_ASHR
    0U,	// G_ICMP
    0U,	// G_FCMP
    0U,	// G_SELECT
    0U,	// G_UADDE
    0U,	// G_USUBE
    0U,	// G_SADDO
    0U,	// G_SSUBO
    0U,	// G_UMULO
    0U,	// G_SMULO
    0U,	// G_FADD
    0U,	// G_FSUB
    0U,	// G_FMUL
    0U,	// G_FDIV
    0U,	// G_FREM
    0U,	// G_FPEXT
    0U,	// G_FPTRUNC
    0U,	// G_FPTOSI
    0U,	// G_FPTOUI
    0U,	// G_SITOFP
    0U,	// G_UITOFP
    0U,	// G_GEP
    0U,	// G_BR
    0U,	// ADD_ri
    0U,	// ADD_rr
    0U,	// ADJCALLSTACKDOWN
    0U,	// ADJCALLSTACKUP
    0U,	// AND_ri
    0U,	// AND_rr
    0U,	// BSWAP16
    0U,	// BSWAP32
    0U,	// BSWAP64
    0U,	// DIV_ri
    0U,	// DIV_rr
    0U,	// FI_ri
    0U,	// JAL
    0U,	// JEQ_ri
    0U,	// JEQ_rr
    0U,	// JMP
    0U,	// JNE_ri
    0U,	// JNE_rr
    0U,	// JSGE_ri
    0U,	// JSGE_rr
    0U,	// JSGT_ri
    0U,	// JSGT_rr
    0U,	// JUGE_ri
    0U,	// JUGE_rr
    0U,	// JUGT_ri
    0U,	// JUGT_rr
    0U,	// LDB
    0U,	// LDD
    0U,	// LDH
    0U,	// LDW
    0U,	// LD_ABS_B
    0U,	// LD_ABS_H
    0U,	// LD_ABS_W
    0U,	// LD_IND_B
    0U,	// LD_IND_H
    0U,	// LD_IND_W
    1U,	// LD_imm64
    2U,	// LD_pseudo
    6U,	// MOV_ri
    6U,	// MOV_rr
    0U,	// MUL_ri
    0U,	// MUL_rr
    0U,	// NOP
    0U,	// OR_ri
    0U,	// OR_rr
    0U,	// RET
    0U,	// SLL_ri
    0U,	// SLL_rr
    0U,	// SRA_ri
    0U,	// SRA_rr
    0U,	// SRL_ri
    0U,	// SRL_rr
    0U,	// STB
    0U,	// STD
    0U,	// STH
    0U,	// STW
    0U,	// SUB_ri
    0U,	// SUB_rr
    10U,	// Select
    0U,	// XADD32
    0U,	// XADD64
    0U,	// XOR_ri
    0U,	// XOR_rr
  };

  O << "\t";

  // Emit the opcode for the instruction.
  uint32_t Bits = 0;
  Bits |= OpInfo0[MI->getOpcode()] << 0;
  Bits |= OpInfo1[MI->getOpcode()] << 16;
  assert(Bits != 0 && "Cannot print this instruction.");
  O << AsmStrs+(Bits & 511)-1;


  // Fragment 0 encoded into 2 bits for 4 unique commands.
  switch ((Bits >> 9) & 3) {
  default: llvm_unreachable("Invalid command number.");
  case 0:
    // DBG_VALUE, BUNDLE, LIFETIME_START, LIFETIME_END, PATCHABLE_FUNCTION_EN...
    return;
    break;
  case 1:
    // ADD_ri, ADD_rr, ADJCALLSTACKDOWN, ADJCALLSTACKUP, AND_ri, AND_rr, BSWA...
    printOperand(MI, 0, O);
    break;
  case 2:
    // LD_ABS_B, LD_ABS_H, LD_ABS_W, LD_IND_B, LD_IND_H, LD_IND_W
    printOperand(MI, 1, O);
    O << ']';
    return;
    break;
  case 3:
    // STB, STD, STH, STW, XADD32, XADD64
    printMemOperand(MI, 1, O);
    break;
  }


  // Fragment 1 encoded into 5 bits for 26 unique commands.
  switch ((Bits >> 11) & 31) {
  default: llvm_unreachable("Invalid command number.");
  case 0:
    // ADD_ri, ADD_rr
    O << " += ";
    printOperand(MI, 2, O);
    return;
    break;
  case 1:
    // ADJCALLSTACKDOWN, BSWAP16, BSWAP32, BSWAP64, JAL, JMP, NOP
    return;
    break;
  case 2:
    // ADJCALLSTACKUP
    O << ' ';
    printOperand(MI, 1, O);
    return;
    break;
  case 3:
    // AND_ri, AND_rr
    O << " &= ";
    printOperand(MI, 2, O);
    return;
    break;
  case 4:
    // DIV_ri, DIV_rr
    O << " /= ";
    printOperand(MI, 2, O);
    return;
    break;
  case 5:
    // FI_ri, LD_pseudo
    O << ", ";
    break;
  case 6:
    // JEQ_ri, JEQ_rr
    O << " == ";
    printOperand(MI, 1, O);
    O << " goto ";
    printOperand(MI, 2, O);
    return;
    break;
  case 7:
    // JNE_ri, JNE_rr
    O << " != ";
    printOperand(MI, 1, O);
    O << " goto ";
    printOperand(MI, 2, O);
    return;
    break;
  case 8:
    // JSGE_ri, JSGE_rr
    O << " s>= ";
    printOperand(MI, 1, O);
    O << " goto ";
    printOperand(MI, 2, O);
    return;
    break;
  case 9:
    // JSGT_ri, JSGT_rr
    O << " s> ";
    printOperand(MI, 1, O);
    O << " goto ";
    printOperand(MI, 2, O);
    return;
    break;
  case 10:
    // JUGE_ri, JUGE_rr
    O << " >= ";
    printOperand(MI, 1, O);
    O << " goto ";
    printOperand(MI, 2, O);
    return;
    break;
  case 11:
    // JUGT_ri, JUGT_rr
    O << " > ";
    printOperand(MI, 1, O);
    O << " goto ";
    printOperand(MI, 2, O);
    return;
    break;
  case 12:
    // LDB
    O << " = *(u8 *)(";
    printMemOperand(MI, 1, O);
    O << ')';
    return;
    break;
  case 13:
    // LDD
    O << " = *(u64 *)(";
    printMemOperand(MI, 1, O);
    O << ')';
    return;
    break;
  case 14:
    // LDH
    O << " = *(u16 *)(";
    printMemOperand(MI, 1, O);
    O << ')';
    return;
    break;
  case 15:
    // LDW
    O << " = *(u32 *)(";
    printMemOperand(MI, 1, O);
    O << ')';
    return;
    break;
  case 16:
    // LD_imm64, MOV_ri, MOV_rr, Select
    O << " = ";
    break;
  case 17:
    // MUL_ri, MUL_rr
    O << " *= ";
    printOperand(MI, 2, O);
    return;
    break;
  case 18:
    // OR_ri, OR_rr
    O << " |= ";
    printOperand(MI, 2, O);
    return;
    break;
  case 19:
    // SLL_ri, SLL_rr
    O << " <<= ";
    printOperand(MI, 2, O);
    return;
    break;
  case 20:
    // SRA_ri, SRA_rr
    O << " s>>= ";
    printOperand(MI, 2, O);
    return;
    break;
  case 21:
    // SRL_ri, SRL_rr
    O << " >>= ";
    printOperand(MI, 2, O);
    return;
    break;
  case 22:
    // STB, STD, STH, STW
    O << ") = ";
    printOperand(MI, 0, O);
    return;
    break;
  case 23:
    // SUB_ri, SUB_rr
    O << " -= ";
    printOperand(MI, 2, O);
    return;
    break;
  case 24:
    // XADD32, XADD64
    O << ") += ";
    printOperand(MI, 3, O);
    return;
    break;
  case 25:
    // XOR_ri, XOR_rr
    O << " ^= ";
    printOperand(MI, 2, O);
    return;
    break;
  }


  // Fragment 2 encoded into 2 bits for 3 unique commands.
  switch ((Bits >> 16) & 3) {
  default: llvm_unreachable("Invalid command number.");
  case 0:
    // FI_ri
    printMemOperand(MI, 1, O);
    return;
    break;
  case 1:
    // LD_imm64
    printImm64Operand(MI, 1, O);
    O << "ll";
    return;
    break;
  case 2:
    // LD_pseudo, MOV_ri, MOV_rr, Select
    printOperand(MI, 1, O);
    break;
  }


  // Fragment 3 encoded into 2 bits for 3 unique commands.
  switch ((Bits >> 18) & 3) {
  default: llvm_unreachable("Invalid command number.");
  case 0:
    // LD_pseudo
    O << ", ";
    printImm64Operand(MI, 2, O);
    return;
    break;
  case 1:
    // MOV_ri, MOV_rr
    return;
    break;
  case 2:
    // Select
    O << ' ';
    printOperand(MI, 3, O);
    O << ' ';
    printOperand(MI, 2, O);
    O << " ? ";
    printOperand(MI, 4, O);
    O << " : ";
    printOperand(MI, 5, O);
    return;
    break;
  }

}


/// getRegisterName - This method is automatically generated by tblgen
/// from the register set description.  This returns the assembler name
/// for the specified register.
const char *BPFInstPrinter::getRegisterName(unsigned RegNo) {
  assert(RegNo && RegNo < 13 && "Invalid register number!");

  static const char AsmStrs[] = {
  /* 0 */ 'r', '1', '0', 0,
  /* 4 */ 'r', '0', 0,
  /* 7 */ 'r', '1', '1', 0,
  /* 11 */ 'r', '1', 0,
  /* 14 */ 'r', '2', 0,
  /* 17 */ 'r', '3', 0,
  /* 20 */ 'r', '4', 0,
  /* 23 */ 'r', '5', 0,
  /* 26 */ 'r', '6', 0,
  /* 29 */ 'r', '7', 0,
  /* 32 */ 'r', '8', 0,
  /* 35 */ 'r', '9', 0,
  };

  static const uint8_t RegAsmOffset[] = {
    4, 11, 14, 17, 20, 23, 26, 29, 32, 35, 0, 7, 
  };

  assert (*(AsmStrs+RegAsmOffset[RegNo-1]) &&
          "Invalid alt name index for register!");
  return AsmStrs+RegAsmOffset[RegNo-1];
}

#ifdef PRINT_ALIAS_INSTR
#undef PRINT_ALIAS_INSTR

bool BPFInstPrinter::printAliasInstr(const MCInst *MI, raw_ostream &OS) {
  return false;
}

#endif // PRINT_ALIAS_INSTR
