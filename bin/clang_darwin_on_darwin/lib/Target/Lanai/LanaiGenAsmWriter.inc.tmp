/*===- TableGen'erated file -------------------------------------*- C++ -*-===*\
|*                                                                            *|
|* Assembly Writer Source Fragment                                            *|
|*                                                                            *|
|* Automatically generated file, do not edit!                                 *|
|*                                                                            *|
\*===----------------------------------------------------------------------===*/

/// printInstruction - This method is automatically generated by tablegen
/// from the instruction set description.
void LanaiInstPrinter::printInstruction(const MCInst *MI, raw_ostream &O) {
  static const char AsmStrs[] = {
  /* 0 */ 's', 'h', 'a', 9, 0,
  /* 5 */ 'u', 'l', 'd', '.', 'b', 9, 0,
  /* 12 */ 's', 't', '.', 'b', 9, 0,
  /* 18 */ 's', 'u', 'b', 'b', 9, 0,
  /* 24 */ 's', 'u', 'b', 9, 0,
  /* 29 */ 'a', 'd', 'd', 'c', 9, 0,
  /* 35 */ 'p', 'o', 'p', 'c', 9, 0,
  /* 41 */ 'a', 'd', 'd', 9, 0,
  /* 46 */ 'u', 'l', 'd', 9, 0,
  /* 51 */ 'a', 'n', 'd', 9, 0,
  /* 56 */ 's', 'h', 'a', '.', 'f', 9, 0,
  /* 63 */ 's', 'u', 'b', 'b', '.', 'f', 9, 0,
  /* 71 */ 's', 'u', 'b', '.', 'f', 9, 0,
  /* 78 */ 'a', 'd', 'd', 'c', '.', 'f', 9, 0,
  /* 86 */ 'a', 'd', 'd', '.', 'f', 9, 0,
  /* 93 */ 'a', 'n', 'd', '.', 'f', 9, 0,
  /* 100 */ 's', 'h', '.', 'f', 9, 0,
  /* 106 */ 'x', 'o', 'r', '.', 'f', 9, 0,
  /* 113 */ 'u', 'l', 'd', '.', 'h', 9, 0,
  /* 120 */ 's', 't', '.', 'h', 9, 0,
  /* 126 */ 's', 'h', 9, 0,
  /* 130 */ 'x', 'o', 'r', 9, 0,
  /* 135 */ 'b', 't', 9, 0,
  /* 139 */ 's', 't', 9, 0,
  /* 143 */ 'm', 'o', 'v', 9, 0,
  /* 148 */ 'l', 'e', 'a', 'd', 'z', 9, 0,
  /* 155 */ 't', 'r', 'a', 'i', 'l', 'z', 9, 0,
  /* 163 */ '#', 'A', 'D', 'J', 'D', 'Y', 'N', 'A', 'L', 'L', 'O', 'C', 32, 0,
  /* 177 */ '#', 'A', 'D', 'J', 'C', 'A', 'L', 'L', 'S', 'T', 'A', 'C', 'K', 'D', 'O', 'W', 'N', 32, 0,
  /* 196 */ '#', 'A', 'D', 'J', 'C', 'A', 'L', 'L', 'S', 'T', 'A', 'C', 'K', 'U', 'P', 32, 0,
  /* 213 */ '#', 32, 'X', 'R', 'a', 'y', 32, 'F', 'u', 'n', 'c', 't', 'i', 'o', 'n', 32, 'P', 'a', 't', 'c', 'h', 'a', 'b', 'l', 'e', 32, 'R', 'E', 'T', '.', 0,
  /* 244 */ '#', 32, 'X', 'R', 'a', 'y', 32, 'C', 'u', 's', 't', 'o', 'm', 32, 'E', 'v', 'e', 'n', 't', 32, 'L', 'o', 'g', '.', 0,
  /* 269 */ 's', 'e', 'l', '.', 0,
  /* 274 */ '#', 32, 'X', 'R', 'a', 'y', 32, 'F', 'u', 'n', 'c', 't', 'i', 'o', 'n', 32, 'E', 'n', 't', 'e', 'r', '.', 0,
  /* 297 */ '#', 32, 'X', 'R', 'a', 'y', 32, 'T', 'a', 'i', 'l', 32, 'C', 'a', 'l', 'l', 32, 'E', 'x', 'i', 't', '.', 0,
  /* 320 */ '#', 32, 'X', 'R', 'a', 'y', 32, 'F', 'u', 'n', 'c', 't', 'i', 'o', 'n', 32, 'E', 'x', 'i', 't', '.', 0,
  /* 342 */ 'l', 'o', 'g', '_', '0', 0,
  /* 348 */ 'l', 'o', 'g', '_', '1', 0,
  /* 354 */ 'l', 'o', 'g', '_', '2', 0,
  /* 360 */ 'l', 'o', 'g', '_', '3', 0,
  /* 366 */ 'l', 'o', 'g', '_', '4', 0,
  /* 372 */ 'L', 'I', 'F', 'E', 'T', 'I', 'M', 'E', '_', 'E', 'N', 'D', 0,
  /* 385 */ 'B', 'U', 'N', 'D', 'L', 'E', 0,
  /* 392 */ 'D', 'B', 'G', '_', 'V', 'A', 'L', 'U', 'E', 0,
  /* 402 */ 'L', 'I', 'F', 'E', 'T', 'I', 'M', 'E', '_', 'S', 'T', 'A', 'R', 'T', 0,
  /* 417 */ 's', 'h', 'a', 0,
  /* 421 */ 's', 'u', 'b', 'b', 0,
  /* 426 */ 's', 'u', 'b', 0,
  /* 430 */ 'a', 'd', 'd', 'c', 0,
  /* 435 */ 'a', 'd', 'd', 0,
  /* 439 */ 'a', 'n', 'd', 0,
  /* 443 */ 's', 'h', 'a', '.', 'f', 0,
  /* 449 */ 's', 'u', 'b', 'b', '.', 'f', 0,
  /* 456 */ 's', 'u', 'b', '.', 'f', 0,
  /* 462 */ 'a', 'd', 'd', 'c', '.', 'f', 0,
  /* 469 */ 'a', 'd', 'd', '.', 'f', 0,
  /* 475 */ 'a', 'n', 'd', '.', 'f', 0,
  /* 481 */ 's', 'h', '.', 'f', 0,
  /* 486 */ 'x', 'o', 'r', '.', 'f', 0,
  /* 492 */ 's', 'h', 0,
  /* 495 */ '#', 32, 'F', 'E', 'n', 't', 'r', 'y', 32, 'c', 'a', 'l', 'l', 0,
  /* 509 */ 'l', 'd', 9, '-', '4', '[', '%', 'f', 'p', ']', ',', 32, '%', 'p', 'c', 32, '!', 32, 'r', 'e', 't', 'u', 'r', 'n', 0,
  /* 534 */ 'n', 'o', 'p', 0,
  /* 538 */ 'x', 'o', 'r', 0,
  /* 542 */ 's', 0,
  };

  static const uint16_t OpInfo0[] = {
    0U,	// PHI
    0U,	// INLINEASM
    0U,	// CFI_INSTRUCTION
    0U,	// EH_LABEL
    0U,	// GC_LABEL
    0U,	// KILL
    0U,	// EXTRACT_SUBREG
    0U,	// INSERT_SUBREG
    0U,	// IMPLICIT_DEF
    0U,	// SUBREG_TO_REG
    0U,	// COPY_TO_REGCLASS
    393U,	// DBG_VALUE
    0U,	// REG_SEQUENCE
    0U,	// COPY
    386U,	// BUNDLE
    403U,	// LIFETIME_START
    373U,	// LIFETIME_END
    0U,	// STACKMAP
    496U,	// FENTRY_CALL
    0U,	// PATCHPOINT
    0U,	// LOAD_STACK_GUARD
    0U,	// STATEPOINT
    0U,	// LOCAL_ESCAPE
    0U,	// FAULTING_OP
    0U,	// PATCHABLE_OP
    275U,	// PATCHABLE_FUNCTION_ENTER
    214U,	// PATCHABLE_RET
    321U,	// PATCHABLE_FUNCTION_EXIT
    298U,	// PATCHABLE_TAIL_CALL
    245U,	// PATCHABLE_EVENT_CALL
    0U,	// G_ADD
    0U,	// G_SUB
    0U,	// G_MUL
    0U,	// G_SDIV
    0U,	// G_UDIV
    0U,	// G_SREM
    0U,	// G_UREM
    0U,	// G_AND
    0U,	// G_OR
    0U,	// G_XOR
    0U,	// G_FRAME_INDEX
    0U,	// G_GLOBAL_VALUE
    0U,	// G_EXTRACT
    0U,	// G_UNMERGE_VALUES
    0U,	// G_INSERT
    0U,	// G_SEQUENCE
    0U,	// G_MERGE_VALUES
    0U,	// G_PTRTOINT
    0U,	// G_INTTOPTR
    0U,	// G_BITCAST
    0U,	// G_LOAD
    0U,	// G_STORE
    0U,	// G_BRCOND
    0U,	// G_BRINDIRECT
    0U,	// G_INTRINSIC
    0U,	// G_INTRINSIC_W_SIDE_EFFECTS
    0U,	// G_ANYEXT
    0U,	// G_TRUNC
    0U,	// G_CONSTANT
    0U,	// G_FCONSTANT
    0U,	// G_VASTART
    0U,	// G_VAARG
    0U,	// G_SEXT
    0U,	// G_ZEXT
    0U,	// G_SHL
    0U,	// G_LSHR
    0U,	// G_ASHR
    0U,	// G_ICMP
    0U,	// G_FCMP
    0U,	// G_SELECT
    0U,	// G_UADDE
    0U,	// G_USUBE
    0U,	// G_SADDO
    0U,	// G_SSUBO
    0U,	// G_UMULO
    0U,	// G_SMULO
    0U,	// G_UMULH
    0U,	// G_SMULH
    0U,	// G_FADD
    0U,	// G_FSUB
    0U,	// G_FMUL
    0U,	// G_FDIV
    0U,	// G_FREM
    0U,	// G_FPOW
    0U,	// G_FNEG
    0U,	// G_FPEXT
    0U,	// G_FPTRUNC
    0U,	// G_FPTOSI
    0U,	// G_FPTOUI
    0U,	// G_SITOFP
    0U,	// G_UITOFP
    0U,	// G_GEP
    0U,	// G_PTR_MASK
    0U,	// G_BR
    0U,	// G_INSERT_VECTOR_ELT
    0U,	// G_EXTRACT_VECTOR_ELT
    0U,	// G_SHUFFLE_VECTOR
    1103U,	// ADDC_F_I_HI
    17487U,	// ADDC_F_I_LO
    2511U,	// ADDC_F_R
    1054U,	// ADDC_I_HI
    17438U,	// ADDC_I_LO
    2479U,	// ADDC_R
    1111U,	// ADD_F_I_HI
    17495U,	// ADD_F_I_LO
    2518U,	// ADD_F_R
    1066U,	// ADD_I_HI
    17450U,	// ADD_I_LO
    2484U,	// ADD_R
    36018U,	// ADJCALLSTACKDOWN
    36037U,	// ADJCALLSTACKUP
    36004U,	// ADJDYNALLOC
    50270U,	// AND_F_I_HI
    1118U,	// AND_F_I_LO
    2524U,	// AND_F_R
    50228U,	// AND_I_HI
    1076U,	// AND_I_LO
    2488U,	// AND_R
    20905U,	// BRCC
    20905U,	// BRIND_CC
    5545U,	// BRIND_CCA
    37289U,	// BRR
    52360U,	// BT
    0U,	// CALL
    0U,	// CALLR
    52360U,	// JR
    6192U,	// LDADDR
    7175U,	// LDBs_RI
    8199U,	// LDBs_RR
    7174U,	// LDBz_RI
    8198U,	// LDBz_RR
    7283U,	// LDHs_RI
    8307U,	// LDHs_RR
    7282U,	// LDHz_RI
    8306U,	// LDHz_RR
    9263U,	// LDW_RI
    8240U,	// LDW_RR
    8239U,	// LDWz_RR
    1173U,	// LEADZ
    343U,	// LOG0
    349U,	// LOG1
    355U,	// LOG2
    361U,	// LOG3
    367U,	// LOG4
    10384U,	// MOVHI
    535U,	// NOP
    1132U,	// OR_F_I_HI
    17516U,	// OR_F_I_LO
    2536U,	// OR_F_R
    1156U,	// OR_I_HI
    17540U,	// OR_I_LO
    2588U,	// OR_R
    1060U,	// POPC
    510U,	// RET
    17465U,	// SA_F_I
    17409U,	// SA_I
    21023U,	// SCC
    11534U,	// SELECT
    19528U,	// SFSUB_F_RI_HI
    19528U,	// SFSUB_F_RI_LO
    19528U,	// SFSUB_F_RR
    2530U,	// SHL_F_R
    2541U,	// SHL_R
    1168U,	// SLI
    17509U,	// SL_F_I
    17535U,	// SL_I
    2492U,	// SRA_F_R
    2466U,	// SRA_R
    2530U,	// SRL_F_R
    2541U,	// SRL_R
    19596U,	// STADDR
    19469U,	// STB_RI
    19469U,	// STB_RR
    19577U,	// STH_RI
    19577U,	// STH_RR
    1088U,	// SUBB_F_I_HI
    17472U,	// SUBB_F_I_LO
    2498U,	// SUBB_F_R
    1043U,	// SUBB_I_HI
    17427U,	// SUBB_I_LO
    2470U,	// SUBB_R
    1096U,	// SUB_F_I_HI
    17480U,	// SUB_F_I_LO
    2505U,	// SUB_F_R
    1049U,	// SUB_I_HI
    17433U,	// SUB_I_LO
    2475U,	// SUB_R
    19596U,	// SW_RI
    19596U,	// SW_RR
    1180U,	// TRAILZ
    1131U,	// XOR_F_I_HI
    17515U,	// XOR_F_I_LO
    2535U,	// XOR_F_R
    1155U,	// XOR_I_HI
    17539U,	// XOR_I_LO
    2587U,	// XOR_R
  };

  static const uint8_t OpInfo1[] = {
    0U,	// PHI
    0U,	// INLINEASM
    0U,	// CFI_INSTRUCTION
    0U,	// EH_LABEL
    0U,	// GC_LABEL
    0U,	// KILL
    0U,	// EXTRACT_SUBREG
    0U,	// INSERT_SUBREG
    0U,	// IMPLICIT_DEF
    0U,	// SUBREG_TO_REG
    0U,	// COPY_TO_REGCLASS
    0U,	// DBG_VALUE
    0U,	// REG_SEQUENCE
    0U,	// COPY
    0U,	// BUNDLE
    0U,	// LIFETIME_START
    0U,	// LIFETIME_END
    0U,	// STACKMAP
    0U,	// FENTRY_CALL
    0U,	// PATCHPOINT
    0U,	// LOAD_STACK_GUARD
    0U,	// STATEPOINT
    0U,	// LOCAL_ESCAPE
    0U,	// FAULTING_OP
    0U,	// PATCHABLE_OP
    0U,	// PATCHABLE_FUNCTION_ENTER
    0U,	// PATCHABLE_RET
    0U,	// PATCHABLE_FUNCTION_EXIT
    0U,	// PATCHABLE_TAIL_CALL
    0U,	// PATCHABLE_EVENT_CALL
    0U,	// G_ADD
    0U,	// G_SUB
    0U,	// G_MUL
    0U,	// G_SDIV
    0U,	// G_UDIV
    0U,	// G_SREM
    0U,	// G_UREM
    0U,	// G_AND
    0U,	// G_OR
    0U,	// G_XOR
    0U,	// G_FRAME_INDEX
    0U,	// G_GLOBAL_VALUE
    0U,	// G_EXTRACT
    0U,	// G_UNMERGE_VALUES
    0U,	// G_INSERT
    0U,	// G_SEQUENCE
    0U,	// G_MERGE_VALUES
    0U,	// G_PTRTOINT
    0U,	// G_INTTOPTR
    0U,	// G_BITCAST
    0U,	// G_LOAD
    0U,	// G_STORE
    0U,	// G_BRCOND
    0U,	// G_BRINDIRECT
    0U,	// G_INTRINSIC
    0U,	// G_INTRINSIC_W_SIDE_EFFECTS
    0U,	// G_ANYEXT
    0U,	// G_TRUNC
    0U,	// G_CONSTANT
    0U,	// G_FCONSTANT
    0U,	// G_VASTART
    0U,	// G_VAARG
    0U,	// G_SEXT
    0U,	// G_ZEXT
    0U,	// G_SHL
    0U,	// G_LSHR
    0U,	// G_ASHR
    0U,	// G_ICMP
    0U,	// G_FCMP
    0U,	// G_SELECT
    0U,	// G_UADDE
    0U,	// G_USUBE
    0U,	// G_SADDO
    0U,	// G_SSUBO
    0U,	// G_UMULO
    0U,	// G_SMULO
    0U,	// G_UMULH
    0U,	// G_SMULH
    0U,	// G_FADD
    0U,	// G_FSUB
    0U,	// G_FMUL
    0U,	// G_FDIV
    0U,	// G_FREM
    0U,	// G_FPOW
    0U,	// G_FNEG
    0U,	// G_FPEXT
    0U,	// G_FPTRUNC
    0U,	// G_FPTOSI
    0U,	// G_FPTOUI
    0U,	// G_SITOFP
    0U,	// G_UITOFP
    0U,	// G_GEP
    0U,	// G_PTR_MASK
    0U,	// G_BR
    0U,	// G_INSERT_VECTOR_ELT
    0U,	// G_EXTRACT_VECTOR_ELT
    0U,	// G_SHUFFLE_VECTOR
    0U,	// ADDC_F_I_HI
    0U,	// ADDC_F_I_LO
    0U,	// ADDC_F_R
    0U,	// ADDC_I_HI
    0U,	// ADDC_I_LO
    0U,	// ADDC_R
    0U,	// ADD_F_I_HI
    0U,	// ADD_F_I_LO
    0U,	// ADD_F_R
    0U,	// ADD_I_HI
    0U,	// ADD_I_LO
    0U,	// ADD_R
    0U,	// ADJCALLSTACKDOWN
    0U,	// ADJCALLSTACKUP
    0U,	// ADJDYNALLOC
    0U,	// AND_F_I_HI
    1U,	// AND_F_I_LO
    0U,	// AND_F_R
    0U,	// AND_I_HI
    1U,	// AND_I_LO
    0U,	// AND_R
    1U,	// BRCC
    1U,	// BRIND_CC
    0U,	// BRIND_CCA
    1U,	// BRR
    1U,	// BT
    0U,	// CALL
    0U,	// CALLR
    1U,	// JR
    0U,	// LDADDR
    0U,	// LDBs_RI
    0U,	// LDBs_RR
    0U,	// LDBz_RI
    0U,	// LDBz_RR
    0U,	// LDHs_RI
    0U,	// LDHs_RR
    0U,	// LDHz_RI
    0U,	// LDHz_RR
    0U,	// LDW_RI
    0U,	// LDW_RR
    0U,	// LDWz_RR
    2U,	// LEADZ
    0U,	// LOG0
    0U,	// LOG1
    0U,	// LOG2
    0U,	// LOG3
    0U,	// LOG4
    0U,	// MOVHI
    0U,	// NOP
    0U,	// OR_F_I_HI
    0U,	// OR_F_I_LO
    0U,	// OR_F_R
    0U,	// OR_I_HI
    0U,	// OR_I_LO
    0U,	// OR_R
    2U,	// POPC
    0U,	// RET
    0U,	// SA_F_I
    0U,	// SA_I
    1U,	// SCC
    0U,	// SELECT
    2U,	// SFSUB_F_RI_HI
    6U,	// SFSUB_F_RI_LO
    6U,	// SFSUB_F_RR
    0U,	// SHL_F_R
    0U,	// SHL_R
    2U,	// SLI
    0U,	// SL_F_I
    0U,	// SL_I
    0U,	// SRA_F_R
    0U,	// SRA_R
    0U,	// SRL_F_R
    0U,	// SRL_R
    10U,	// STADDR
    14U,	// STB_RI
    18U,	// STB_RR
    14U,	// STH_RI
    18U,	// STH_RR
    0U,	// SUBB_F_I_HI
    0U,	// SUBB_F_I_LO
    0U,	// SUBB_F_R
    0U,	// SUBB_I_HI
    0U,	// SUBB_I_LO
    0U,	// SUBB_R
    0U,	// SUB_F_I_HI
    0U,	// SUB_F_I_LO
    0U,	// SUB_F_R
    0U,	// SUB_I_HI
    0U,	// SUB_I_LO
    0U,	// SUB_R
    22U,	// SW_RI
    18U,	// SW_RR
    2U,	// TRAILZ
    0U,	// XOR_F_I_HI
    0U,	// XOR_F_I_LO
    0U,	// XOR_F_R
    0U,	// XOR_I_HI
    0U,	// XOR_I_LO
    0U,	// XOR_R
  };

  O << "\t";

  // Emit the opcode for the instruction.
  uint32_t Bits = 0;
  Bits |= OpInfo0[MI->getOpcode()] << 0;
  Bits |= OpInfo1[MI->getOpcode()] << 16;
  assert(Bits != 0 && "Cannot print this instruction.");
  O << AsmStrs+(Bits & 1023)-1;


  // Fragment 0 encoded into 4 bits for 12 unique commands.
  switch ((Bits >> 10) & 15) {
  default: llvm_unreachable("Invalid command number.");
  case 0:
    // DBG_VALUE, BUNDLE, LIFETIME_START, LIFETIME_END, FENTRY_CALL, PATCHABL...
    return;
    break;
  case 1:
    // ADDC_F_I_HI, ADDC_F_I_LO, ADDC_I_HI, ADDC_I_LO, ADD_F_I_HI, ADD_F_I_LO...
    printOperand(MI, 1, O);
    O << ", ";
    break;
  case 2:
    // ADDC_F_R, ADDC_R, ADD_F_R, ADD_R, AND_F_R, AND_R, OR_F_R, OR_R, SHL_F_...
    printPredicateOperand(MI, 3, O);
    O << "\t";
    printOperand(MI, 1, O);
    O << ", ";
    printOperand(MI, 2, O);
    O << ", ";
    printOperand(MI, 0, O);
    return;
    break;
  case 3:
    // ADJCALLSTACKDOWN, ADJCALLSTACKUP, ADJDYNALLOC, BT, JR, SFSUB_F_RI_HI, ...
    printOperand(MI, 0, O);
    break;
  case 4:
    // BRCC, BRIND_CC, BRR, SCC
    printCCOperand(MI, 1, O);
    break;
  case 5:
    // BRIND_CCA
    printCCOperand(MI, 2, O);
    O << "\t";
    printOperand(MI, 0, O);
    O << " add ";
    printOperand(MI, 1, O);
    return;
    break;
  case 6:
    // LDADDR
    printMemImmOperand(MI, 1, O);
    O << ", ";
    printOperand(MI, 0, O);
    return;
    break;
  case 7:
    // LDBs_RI, LDBz_RI, LDHs_RI, LDHz_RI
    printMemSplsOperand(MI, 1, O);
    O << ", ";
    printOperand(MI, 0, O);
    return;
    break;
  case 8:
    // LDBs_RR, LDBz_RR, LDHs_RR, LDHz_RR, LDW_RR, LDWz_RR
    printMemRrOperand(MI, 1, O);
    O << ", ";
    printOperand(MI, 0, O);
    return;
    break;
  case 9:
    // LDW_RI
    printMemRiOperand(MI, 1, O);
    O << ", ";
    printOperand(MI, 0, O);
    return;
    break;
  case 10:
    // MOVHI
    printHi16ImmOperand(MI, 1, O);
    O << ", ";
    printOperand(MI, 0, O);
    return;
    break;
  case 11:
    // SELECT
    printCCOperand(MI, 3, O);
    O << ' ';
    printOperand(MI, 1, O);
    O << ", ";
    printOperand(MI, 2, O);
    O << ", ";
    printOperand(MI, 0, O);
    return;
    break;
  }


  // Fragment 1 encoded into 4 bits for 10 unique commands.
  switch ((Bits >> 14) & 15) {
  default: llvm_unreachable("Invalid command number.");
  case 0:
    // ADDC_F_I_HI, ADDC_I_HI, ADD_F_I_HI, ADD_I_HI, OR_F_I_HI, OR_I_HI, SUBB...
    printHi16ImmOperand(MI, 2, O);
    O << ", ";
    printOperand(MI, 0, O);
    return;
    break;
  case 1:
    // ADDC_F_I_LO, ADDC_I_LO, ADD_F_I_LO, ADD_I_LO, OR_F_I_LO, OR_I_LO, SA_F...
    printOperand(MI, 2, O);
    O << ", ";
    printOperand(MI, 0, O);
    return;
    break;
  case 2:
    // ADJCALLSTACKDOWN, ADJCALLSTACKUP, ADJDYNALLOC
    O << ' ';
    printOperand(MI, 1, O);
    return;
    break;
  case 3:
    // AND_F_I_HI, AND_I_HI
    printHi16AndImmOperand(MI, 2, O);
    O << ", ";
    printOperand(MI, 0, O);
    return;
    break;
  case 4:
    // AND_F_I_LO, AND_I_LO
    printLo16AndImmOperand(MI, 2, O);
    O << ", ";
    printOperand(MI, 0, O);
    return;
    break;
  case 5:
    // BRCC, BRIND_CC, SCC
    O << "\t";
    printOperand(MI, 0, O);
    return;
    break;
  case 6:
    // BRR
    O << ".r\t";
    printOperand(MI, 0, O);
    return;
    break;
  case 7:
    // BT, JR
    return;
    break;
  case 8:
    // LEADZ, POPC, SLI, TRAILZ
    printOperand(MI, 0, O);
    return;
    break;
  case 9:
    // SFSUB_F_RI_HI, SFSUB_F_RI_LO, SFSUB_F_RR, STADDR, STB_RI, STB_RR, STH_...
    O << ", ";
    break;
  }


  // Fragment 2 encoded into 3 bits for 6 unique commands.
  switch ((Bits >> 18) & 7) {
  default: llvm_unreachable("Invalid command number.");
  case 0:
    // SFSUB_F_RI_HI
    printHi16ImmOperand(MI, 1, O);
    O << ", %r0";
    return;
    break;
  case 1:
    // SFSUB_F_RI_LO, SFSUB_F_RR
    printOperand(MI, 1, O);
    O << ", %r0";
    return;
    break;
  case 2:
    // STADDR
    printMemImmOperand(MI, 1, O);
    return;
    break;
  case 3:
    // STB_RI, STH_RI
    printMemSplsOperand(MI, 1, O);
    return;
    break;
  case 4:
    // STB_RR, STH_RR, SW_RR
    printMemRrOperand(MI, 1, O);
    return;
    break;
  case 5:
    // SW_RI
    printMemRiOperand(MI, 1, O);
    return;
    break;
  }

}


/// getRegisterName - This method is automatically generated by tblgen
/// from the register set description.  This returns the assembler name
/// for the specified register.
const char *LanaiInstPrinter::getRegisterName(unsigned RegNo) {
  assert(RegNo && RegNo < 41 && "Invalid register number!");

  static const char AsmStrs[] = {
  /* 0 */ 'r', '1', '0', 0,
  /* 4 */ 'r', '2', '0', 0,
  /* 8 */ 'r', '3', '0', 0,
  /* 12 */ 'r', '0', 0,
  /* 15 */ 'r', '1', '1', 0,
  /* 19 */ 'r', '2', '1', 0,
  /* 23 */ 'r', '3', '1', 0,
  /* 27 */ 'r', 'r', '1', 0,
  /* 31 */ 'r', '1', '2', 0,
  /* 35 */ 'r', '2', '2', 0,
  /* 39 */ 'r', 'r', '2', 0,
  /* 43 */ 'r', '1', '3', 0,
  /* 47 */ 'r', '2', '3', 0,
  /* 51 */ 'r', '3', 0,
  /* 54 */ 'r', '1', '4', 0,
  /* 58 */ 'r', '2', '4', 0,
  /* 62 */ 'r', '4', 0,
  /* 65 */ 'r', '1', '5', 0,
  /* 69 */ 'r', '2', '5', 0,
  /* 73 */ 'r', '5', 0,
  /* 76 */ 'r', '1', '6', 0,
  /* 80 */ 'r', '2', '6', 0,
  /* 84 */ 'r', '6', 0,
  /* 87 */ 'r', '1', '7', 0,
  /* 91 */ 'r', '2', '7', 0,
  /* 95 */ 'r', '7', 0,
  /* 98 */ 'r', '1', '8', 0,
  /* 102 */ 'r', '2', '8', 0,
  /* 106 */ 'r', '8', 0,
  /* 109 */ 'r', '1', '9', 0,
  /* 113 */ 'r', '2', '9', 0,
  /* 117 */ 'r', '9', 0,
  /* 120 */ 'r', 'c', 'a', 0,
  /* 124 */ 'p', 'c', 0,
  /* 127 */ 'f', 'p', 0,
  /* 130 */ 's', 'p', 0,
  /* 133 */ 'r', 'v', 0,
  /* 136 */ 's', 'w', 0,
  };

  static const uint8_t RegAsmOffset[] = {
    127, 124, 120, 133, 130, 136, 12, 28, 40, 51, 62, 73, 84, 95, 
    106, 117, 0, 15, 31, 43, 54, 65, 76, 87, 98, 109, 4, 19, 
    35, 47, 58, 69, 80, 91, 102, 113, 8, 23, 27, 39, 
  };

  assert (*(AsmStrs+RegAsmOffset[RegNo-1]) &&
          "Invalid alt name index for register!");
  return AsmStrs+RegAsmOffset[RegNo-1];
}

#ifdef PRINT_ALIAS_INSTR
#undef PRINT_ALIAS_INSTR

bool LanaiInstPrinter::printAliasInstr(const MCInst *MI, raw_ostream &OS) {
  const char *AsmString;
  switch (MI->getOpcode()) {
  default: return false;
  case Lanai::ADD_I_HI:
    if (MI->getNumOperands() == 3 &&
        MI->getOperand(0).isReg() &&
        MRI.getRegClass(Lanai::GPRRegClassID).contains(MI->getOperand(0).getReg()) &&
        MI->getOperand(1).getReg() == Lanai::R0) {
      // (ADD_I_HI GPR:$dst, R0, i32hi16:$imm16)
      AsmString = "mov $\xFF\x03\x01, $\x01";
      break;
    }
    return false;
  case Lanai::ADD_I_LO:
    if (MI->getNumOperands() == 3 &&
        MI->getOperand(0).isReg() &&
        MRI.getRegClass(Lanai::GPRRegClassID).contains(MI->getOperand(0).getReg()) &&
        MI->getOperand(1).getReg() == Lanai::R0) {
      // (ADD_I_LO GPR:$dst, R0, i32lo16z:$imm16)
      AsmString = "mov $\x03, $\x01";
      break;
    }
    return false;
  case Lanai::ADD_R:
    if (MI->getNumOperands() == 4 &&
        MI->getOperand(0).isReg() &&
        MRI.getRegClass(Lanai::GPRRegClassID).contains(MI->getOperand(0).getReg()) &&
        MI->getOperand(1).isReg() &&
        MRI.getRegClass(Lanai::GPRRegClassID).contains(MI->getOperand(1).getReg()) &&
        MI->getOperand(2).getReg() == Lanai::R0 &&
        MI->getOperand(3).isImm() &&
        MI->getOperand(3).getImm() == 0) {
      // (ADD_R GPR:$dst, GPR:$src, R0, 0)
      AsmString = "mov $\x02, $\x01";
      break;
    }
    return false;
  case Lanai::AND_I_HI:
    if (MI->getNumOperands() == 3 &&
        MI->getOperand(0).isReg() &&
        MRI.getRegClass(Lanai::GPRRegClassID).contains(MI->getOperand(0).getReg()) &&
        MI->getOperand(1).getReg() == Lanai::R1) {
      // (AND_I_HI GPR:$dst, R1, i32hi16and:$imm16)
      AsmString = "mov $\xFF\x03\x02, $\x01";
      break;
    }
    return false;
  case Lanai::AND_I_LO:
    if (MI->getNumOperands() == 3 &&
        MI->getOperand(0).isReg() &&
        MRI.getRegClass(Lanai::GPRRegClassID).contains(MI->getOperand(0).getReg()) &&
        MI->getOperand(1).getReg() == Lanai::R1) {
      // (AND_I_LO GPR:$dst, R1, i32lo16and:$imm16)
      AsmString = "mov $\xFF\x03\x03, $\x01";
      break;
    }
    return false;
  case Lanai::LDW_RI:
    if (MI->getNumOperands() == 4 &&
        MI->getOperand(0).isReg() &&
        MRI.getRegClass(Lanai::GPRRegClassID).contains(MI->getOperand(0).getReg())) {
      // (LDW_RI GPR:$dst, MEMri:$src)
      AsmString = "ld $\xFF\x02\x04, $\x01";
      break;
    }
    return false;
  }

  unsigned I = 0;
  while (AsmString[I] != ' ' && AsmString[I] != '\t' &&
         AsmString[I] != '$' && AsmString[I] != '\0')
    ++I;
  OS << '\t' << StringRef(AsmString, I);
  if (AsmString[I] != '\0') {
    if (AsmString[I] == ' ' || AsmString[I] == '\t')      OS << '\t';
    do {
      if (AsmString[I] == '$') {
        ++I;
        if (AsmString[I] == (char)0xff) {
          ++I;
          int OpIdx = AsmString[I++] - 1;
          int PrintMethodIdx = AsmString[I++] - 1;
          printCustomAliasOperand(MI, OpIdx, PrintMethodIdx, OS);
        } else
          printOperand(MI, unsigned(AsmString[I++]) - 1, OS);
      } else {
        OS << AsmString[I++];
      }
    } while (AsmString[I] != '\0');
  }

  return true;
}

void LanaiInstPrinter::printCustomAliasOperand(
         const MCInst *MI, unsigned OpIdx,
         unsigned PrintMethodIdx,
         raw_ostream &OS) {
  switch (PrintMethodIdx) {
  default:
    llvm_unreachable("Unknown PrintMethod kind");
    break;
  case 0:
    printHi16ImmOperand(MI, OpIdx, OS);
    break;
  case 1:
    printHi16AndImmOperand(MI, OpIdx, OS);
    break;
  case 2:
    printLo16AndImmOperand(MI, OpIdx, OS);
    break;
  case 3:
    printMemRiOperand(MI, OpIdx, OS);
    break;
  }
}

#endif // PRINT_ALIAS_INSTR
